package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"
)

var (
	errsDir     = "./errors/"
	inputFiles  = "auth_errors.go, common_errors.go"
	outputFile  = "error_types.go"
	packageName = "errs"
)

type ErrorStruct struct {
	Name    string
	Status  int
	Code    string
	Message string
}

const structTemplate = `// Code generated by go generate; DO NOT EDIT.
package {{.PackageName}}

{{range .Errors}}
type {{.Name}} struct {
	Status  int    ` + "`json:\"status\" example:\"{{.Status}}\"`" + `
	Code    string ` + "`json:\"code\" example:\"{{.Code}}\"`" + `
	Message string ` + "`json:\"message\" example:\"{{.Message}}\"`" + `
}
{{end}}
`

func main() {
	flag.Parse()

	absOutputPath, err := filepath.Abs(errsDir + outputFile)

	if err != nil {
		log.Fatalf("Failed to get absolute path for output: %v", err)
	}

	files := strings.Split(inputFiles, ",")
	var allErrors []ErrorStruct

	for _, inputFile := range files {
		inputFile = strings.TrimSpace(inputFile)
		absInputPath, err := filepath.Abs(errsDir + inputFile)
		if err != nil {
			log.Printf("Warning: failed to get absolute path for %s: %v", inputFile, err)
			continue
		}

		log.Printf("Processing file: %s", absInputPath)
		errors, err := parseFile(absInputPath)
		if err != nil {
			log.Printf("Error parsing file %s: %v", absInputPath, err)
			continue
		}
		allErrors = append(allErrors, errors...)
	}

	log.Printf("Found %d error declarations", len(allErrors))
	if len(allErrors) == 0 {
		log.Fatal("No error declarations found in input files")
	}

	if err := generateFile(absOutputPath, packageName, allErrors); err != nil {
		log.Fatalf("Generation failed: %v", err)
	}

	log.Printf("Successfully generated %s with %d error types", absOutputPath, len(allErrors))
}

func parseFile(filename string) ([]ErrorStruct, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("parse error: %w", err)
	}

	var errors []ErrorStruct

	codeConstants := make(map[string]string)
	for _, decl := range node.Decls {
		if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.CONST {
			for _, spec := range genDecl.Specs {
				if valueSpec, ok := spec.(*ast.ValueSpec); ok {
					for i, name := range valueSpec.Names {
						if strings.HasPrefix(name.Name, "Code") && i < len(valueSpec.Values) {
							if bl, ok := valueSpec.Values[i].(*ast.BasicLit); ok {
								codeConstants[name.Name] = strings.Trim(bl.Value, `"`)
							}
						}
					}
				}
			}
		}
	}

	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.VAR {
			continue
		}

		for _, spec := range genDecl.Specs {
			valueSpec, ok := spec.(*ast.ValueSpec)
			if !ok || len(valueSpec.Names) == 0 || len(valueSpec.Values) == 0 {
				continue
			}

			varName := valueSpec.Names[0].Name
			errorData := ErrorStruct{Name: varName + "Error"}

			switch v := valueSpec.Values[0].(type) {
			case *ast.UnaryExpr: // &AppError{...}
				if compLit, ok := v.X.(*ast.CompositeLit); ok {
					processCompositeLit(compLit, &errorData, codeConstants)
				}
			case *ast.CompositeLit: // AppError{...}
				processCompositeLit(v, &errorData, codeConstants)
			case *ast.CallExpr: // NewAppError(...)
				processCallExpr(v, &errorData, codeConstants)
			}

			if errorData.Status != 0 && errorData.Code != "" && errorData.Message != "" {
				errors = append(errors, errorData)
			} else {
				fmt.Printf("Incomplete data for %s: %+v\n", varName, errorData)
			}
		}
	}

	return errors, nil
}

func processCompositeLit(compLit *ast.CompositeLit, errorData *ErrorStruct, codeConstants map[string]string) {
	for _, elt := range compLit.Elts {
		kv, ok := elt.(*ast.KeyValueExpr)
		if !ok {
			continue
		}

		key, ok := kv.Key.(*ast.Ident)
		if !ok {
			continue
		}

		switch key.Name {
		case "Status":
			if bl, ok := kv.Value.(*ast.BasicLit); ok {
				if val, err := strconv.Atoi(bl.Value); err == nil {
					errorData.Status = val
				}
			}
		case "Code":
			if ident, ok := kv.Value.(*ast.Ident); ok {
				if code, exists := codeConstants[ident.Name]; exists {
					errorData.Code = toSnakeCase(code)
				} else {
					errorData.Code = toSnakeCase(strings.TrimPrefix(ident.Name, "Code"))
				}
			} else if bl, ok := kv.Value.(*ast.BasicLit); ok {
				errorData.Code = strings.ToUpper(strings.Trim(bl.Value, `"`))
			}
		case "Message":
			if bl, ok := kv.Value.(*ast.BasicLit); ok {
				errorData.Message = strings.Trim(bl.Value, `"`)
			}
		}
	}
}

func toSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			if i == 0 || (i > 0 && s[i-1] != '_') {
				result = append(result, '_')
			}
		}
		result = append(result, r)
	}
	return strings.ToUpper(string(result))
}
func processCallExpr(callExpr *ast.CallExpr, errorData *ErrorStruct, codeConstants map[string]string) {
	//  var X = NewAppError(status, code, message)
}

func generateFile(outputPath, packageName string, errors []ErrorStruct) error {

	if err := os.MkdirAll(filepath.Dir(outputPath), os.ModePerm); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	tmpl, err := template.New("errors").Parse(structTemplate)
	if err != nil {
		return fmt.Errorf("template parse error: %w", err)
	}

	f, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("file create error: %w", err)
	}
	defer f.Close()

	data := struct {
		PackageName string
		Errors      []ErrorStruct
	}{
		PackageName: packageName,
		Errors:      errors,
	}

	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("template execute error: %w", err)
	}

	return nil
}
