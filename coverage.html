
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ddan1l/tega-backend/config/config.go (0.0%)</option>
				
				<option value="file1">github.com/ddan1l/tega-backend/database/mock.go (0.0%)</option>
				
				<option value="file2">github.com/ddan1l/tega-backend/database/postgres.go (0.0%)</option>
				
				<option value="file3">github.com/ddan1l/tega-backend/errors/app_error.go (0.0%)</option>
				
				<option value="file4">github.com/ddan1l/tega-backend/factory/factory.go (0.0%)</option>
				
				<option value="file5">github.com/ddan1l/tega-backend/factory/repositories.go (0.0%)</option>
				
				<option value="file6">github.com/ddan1l/tega-backend/factory/usecases.go (0.0%)</option>
				
				<option value="file7">github.com/ddan1l/tega-backend/handlers/auth/handler.go (0.0%)</option>
				
				<option value="file8">github.com/ddan1l/tega-backend/main.go (0.0%)</option>
				
				<option value="file9">github.com/ddan1l/tega-backend/middleware/auth/middleware.go (0.0%)</option>
				
				<option value="file10">github.com/ddan1l/tega-backend/repositories/token/token_pg_repository.go (0.0%)</option>
				
				<option value="file11">github.com/ddan1l/tega-backend/repositories/user/user_pg_repository.go (100.0%)</option>
				
				<option value="file12">github.com/ddan1l/tega-backend/server/gin_server.go (0.0%)</option>
				
				<option value="file13">github.com/ddan1l/tega-backend/usecases/auth/auth_usecase_impl.go (0.0%)</option>
				
				<option value="file14">github.com/ddan1l/tega-backend/utils/cookies.go (0.0%)</option>
				
				<option value="file15">github.com/ddan1l/tega-backend/utils/password_hash.go (0.0%)</option>
				
				<option value="file16">github.com/ddan1l/tega-backend/web/requests/bind_validate.go (0.0%)</option>
				
				<option value="file17">github.com/ddan1l/tega-backend/web/responses/error_response.go (0.0%)</option>
				
				<option value="file18">github.com/ddan1l/tega-backend/web/responses/success_response.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "strings"
        "sync"

        "github.com/spf13/viper"
)

type (
        Config struct {
                Server *Server
                Db     *Db
        }

        Server struct {
                Port int
        }

        Db struct {
                Host     string
                Port     int
                User     string
                Password string
                DBName   string
                SSLMode  string
                TimeZone string
        }
)

var (
        once           sync.Once
        configInstance *Config
)

func GetConfig() *Config <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                viper.SetConfigName("config")
                viper.SetConfigType("yaml")
                viper.AddConfigPath("./")
                viper.AutomaticEnv()
                viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

                if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov0" title="0">if err := viper.Unmarshal(&amp;configInstance); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        })

        <span class="cov0" title="0">return configInstance</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package database

import (
        "log"

        "github.com/DATA-DOG/go-sqlmock"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

type mockDatabase struct {
        Db *gorm.DB
}

var (
        dbMockInstance *mockDatabase
)

func NewMockDatabase() (Database, sqlmock.Sqlmock) <span class="cov0" title="0">{
        db, mock, err := sqlmock.New()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("An error '%s' was not expected when opening a stub database connection", err)
        }</span>

        <span class="cov0" title="0">gormDB, err := gorm.Open(postgres.New(postgres.Config{
                Conn: db,
        }), &amp;gorm.Config{})

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("An error '%s' was not expected when opening gorm database", err)
        }</span>

        <span class="cov0" title="0">dbMockInstance = &amp;mockDatabase{Db: gormDB}

        return dbMockInstance, mock</span>
}

func (p *mockDatabase) GetDb() *gorm.DB <span class="cov0" title="0">{
        return dbMockInstance.Db
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "fmt"
        "sync"

        "github.com/ddan1l/tega-backend/config"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

type postgresDatabase struct {
        Db *gorm.DB
}

var (
        once       sync.Once
        dbInstance *postgresDatabase
)

func NewPostgresDatabase(conf *config.Config) Database <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                dsn := fmt.Sprintf(
                        "host=%s user=%s password=%s dbname=%s port=%d sslmode=%s TimeZone=%s",
                        conf.Db.Host,
                        conf.Db.User,
                        conf.Db.Password,
                        conf.Db.DBName,
                        conf.Db.Port,
                        conf.Db.SSLMode,
                        conf.Db.TimeZone,
                )

                db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
                if err != nil </span><span class="cov0" title="0">{
                        panic("failed to connect database")</span>
                }

                <span class="cov0" title="0">dbInstance = &amp;postgresDatabase{Db: db}</span>
        })

        <span class="cov0" title="0">return dbInstance</span>
}

func (p *postgresDatabase) GetDb() *gorm.DB <span class="cov0" title="0">{
        return dbInstance.Db
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package errs

import "fmt"

type AppError struct {
        Status  int         `json:"status"`
        Code    string      `json:"code"`
        Message string      `json:"message"`
        Details interface{} `json:"details,omitempty"`
}

func (e *AppError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("status %d: err %v", e.Status, e.Message)
}</span>

func (e *AppError) WithStatus(status int) *AppError <span class="cov0" title="0">{
        e.Status = status
        return e
}</span>

func (e *AppError) WithCode(code string) *AppError <span class="cov0" title="0">{
        e.Code = code
        return e
}</span>

func (e *AppError) WithMessage(message string) *AppError <span class="cov0" title="0">{
        e.Message = message
        return e
}</span>

func (e *AppError) WithDetails(details interface{}) *AppError <span class="cov0" title="0">{
        e.Details = details
        return e
}</span>

func (e *AppError) WithError(err error) *AppError <span class="cov0" title="0">{
        e.Message = fmt.Sprint(err)
        return e
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package factory

import (
        "github.com/ddan1l/tega-backend/database"
)

type DefaultFactory struct {
        db database.Database
}

func NewDefaultFactory(db database.Database) *DefaultFactory <span class="cov0" title="0">{
        return &amp;DefaultFactory{db: db}
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package factory

import (
        token_repository "github.com/ddan1l/tega-backend/repositories/token"
        user_repository "github.com/ddan1l/tega-backend/repositories/user"
)

type RepositoryFactory interface {
        CreateUserRepository() user_repository.UserRepository
        CreateTokenRepository() token_repository.TokenRepository
}

func (f *DefaultFactory) CreateUserRepository() user_repository.UserRepository <span class="cov0" title="0">{
        return user_repository.NewUserPgRepository(f.db)
}</span>

func (f *DefaultFactory) CreateTokenRepository() token_repository.TokenRepository <span class="cov0" title="0">{
        return token_repository.NewTokenPgRepository(f.db)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package factory

import auth_usecase "github.com/ddan1l/tega-backend/usecases/auth"

type UseCaseFactory interface {
        CreateAuthUseCase() auth_usecase.AuthUsecase
}

func (f *DefaultFactory) CreateAuthUseCase() auth_usecase.AuthUsecase <span class="cov0" title="0">{
        return auth_usecase.NewAuthUsecaseImpl(
                f.CreateUserRepository(),
                f.CreateTokenRepository(),
        )
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package auth_handler

import (
        "net/http"

        auth_dto "github.com/ddan1l/tega-backend/dto/auth"
        auth_usecase "github.com/ddan1l/tega-backend/usecases/auth"
        "github.com/ddan1l/tega-backend/utils"

        req "github.com/ddan1l/tega-backend/web/requests"
        res "github.com/ddan1l/tega-backend/web/responses"
        "github.com/gin-gonic/gin"
)

type authHandler struct {
        authUsecase auth_usecase.AuthUsecase
}

func NewAuthHandler(authUsecase auth_usecase.AuthUsecase) AuthHandler <span class="cov0" title="0">{
        return &amp;authHandler{
                authUsecase: authUsecase,
        }
}</span>

func (h *authHandler) Register(c *gin.Context) <span class="cov0" title="0">{
        var r req.RegisterUserRequest

        if !req.BindAndValidate(c, &amp;r) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">dto := auth_dto.RegisterUserDto{
                FullName: r.FullName,
                Email:    r.Email,
                Password: r.Password,
        }

        if pair, err := h.authUsecase.RegisterUser(&amp;dto); err != nil </span><span class="cov0" title="0">{
                res.ErrorResponse(c, err)
        }</span> else<span class="cov0" title="0"> {
                exp := &amp;auth_dto.TokensPairExpirationDto{
                        AccessTokenExpiration:  int(auth_usecase.AccessTokenMaxAge.Seconds()),
                        RefreshTokenExpiration: int(auth_usecase.RefreshTokenMaxAge.Seconds()),
                }

                h.setAuthCookies(c, pair, exp)

                res.SuccessResponse(c)
        }</span>
}

func (h *authHandler) Login(c *gin.Context) <span class="cov0" title="0">{
        var r req.LoginUserRequest

        if !req.BindAndValidate(c, &amp;r) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">dto := auth_dto.LoginUserDto{
                Email:    r.Email,
                Password: r.Password,
        }

        if pair, err := h.authUsecase.LoginUser(&amp;dto); err != nil </span><span class="cov0" title="0">{
                res.ErrorResponse(c, err)
        }</span> else<span class="cov0" title="0"> {
                exp := &amp;auth_dto.TokensPairExpirationDto{
                        AccessTokenExpiration:  int(auth_usecase.AccessTokenMaxAge.Seconds()),
                        RefreshTokenExpiration: int(auth_usecase.RefreshTokenMaxAge.Seconds()),
                }

                h.setAuthCookies(c, pair, exp)

                res.SuccessResponse(c)
        }</span>
}

func (h *authHandler) Logout(c *gin.Context) <span class="cov0" title="0">{
        refreshToken := utils.SafeGetCookie(c, "RefreshToken")

        pair := &amp;auth_dto.TokensPairDto{
                AccessToken:  "",
                RefreshToken: "",
        }

        exp := &amp;auth_dto.TokensPairExpirationDto{
                AccessTokenExpiration:  -1,
                RefreshTokenExpiration: -1,
        }

        h.setAuthCookies(c, pair, exp)

        if refreshToken != "" </span><span class="cov0" title="0">{
                if err := h.authUsecase.DeleteToken(refreshToken); err != nil </span><span class="cov0" title="0">{
                        res.ErrorResponse(c, err)
                        return
                }</span>
        }

        <span class="cov0" title="0">res.SuccessResponse(c)</span>
}

func (h *authHandler) setAuthCookies(c *gin.Context, pair *auth_dto.TokensPairDto, exp *auth_dto.TokensPairExpirationDto) <span class="cov0" title="0">{

        at := &amp;http.Cookie{
                Name:     "AccessToken",
                Value:    pair.AccessToken,
                MaxAge:   exp.AccessTokenExpiration,
                Path:     "/",
                Domain:   "",
                Secure:   false,
                HttpOnly: true,
        }

        rt := &amp;http.Cookie{
                Name:     "RefreshToken",
                Value:    pair.RefreshToken,
                MaxAge:   exp.RefreshTokenExpiration,
                Path:     "/",
                Domain:   "",
                Secure:   false,
                HttpOnly: true,
        }

        http.SetCookie(c.Writer, at)
        http.SetCookie(c.Writer, rt)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "github.com/ddan1l/tega-backend/config"
        "github.com/ddan1l/tega-backend/database"
        "github.com/ddan1l/tega-backend/server"
)

func main() <span class="cov0" title="0">{
        conf := config.GetConfig()

        db := database.NewPostgresDatabase(conf)

        server.NewGinServer(conf, db).Start()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package auth_middleware

import (
        "net/http"

        auth_dto "github.com/ddan1l/tega-backend/dto/auth"
        auth_usecase "github.com/ddan1l/tega-backend/usecases/auth"
        "github.com/ddan1l/tega-backend/utils"
        res "github.com/ddan1l/tega-backend/web/responses"
        "github.com/gin-gonic/gin"
)

type authMiddleware struct {
        authUsecase auth_usecase.AuthUsecase
}

func NewAuthMiddleware(authUsecase auth_usecase.AuthUsecase) AuthMiddleware <span class="cov0" title="0">{
        return &amp;authMiddleware{
                authUsecase: authUsecase,
        }
}</span>

func (m *authMiddleware) Middleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                pair := auth_dto.TokensPairDto{
                        AccessToken:  utils.SafeGetCookie(c, "AccessToken"),
                        RefreshToken: utils.SafeGetCookie(c, "RefreshToken"),
                }

                authenticatedDto, err := m.authUsecase.Authenticate(&amp;pair)

                if err != nil || authenticatedDto == nil || authenticatedDto.User == nil </span><span class="cov0" title="0">{
                        m.clearCookies(c)

                        res.ErrorResponse(c, err)

                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if authenticatedDto.AccessToken != "" </span><span class="cov0" title="0">{
                        m.setAccessTokenCookie(c, authenticatedDto.AccessToken)
                }</span>

                <span class="cov0" title="0">c.Set("user", authenticatedDto.User)
                c.Next()</span>
        }
}

func (m *authMiddleware) setAccessTokenCookie(c *gin.Context, token string) <span class="cov0" title="0">{
        at := &amp;http.Cookie{
                Name:     "AccessToken",
                Value:    token,
                MaxAge:   int(auth_usecase.AccessTokenMaxAge.Seconds()),
                Path:     "/",
                Domain:   "",
                Secure:   false,
                HttpOnly: true,
        }

        http.SetCookie(c.Writer, at)
}</span>

func (m *authMiddleware) clearCookies(c *gin.Context) <span class="cov0" title="0">{
        at := &amp;http.Cookie{
                Name:     "AccessToken",
                Value:    "",
                MaxAge:   -1,
                Path:     "/",
                Domain:   "",
                Secure:   false,
                HttpOnly: true,
        }

        rt := &amp;http.Cookie{
                Name:     "RefreshToken",
                Value:    "",
                MaxAge:   -1,
                Path:     "/",
                Domain:   "",
                Secure:   false,
                HttpOnly: true,
        }

        http.SetCookie(c.Writer, at)
        http.SetCookie(c.Writer, rt)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package token_repository

import (
        "github.com/ddan1l/tega-backend/database"
        auth_dto "github.com/ddan1l/tega-backend/dto/auth"
        "github.com/ddan1l/tega-backend/models"
)

type tokenPgRepository struct {
        db database.Database
}

func NewTokenPgRepository(db database.Database) TokenRepository <span class="cov0" title="0">{
        return &amp;tokenPgRepository{db: db}
}</span>

func (r *tokenPgRepository) Create(in *auth_dto.CreateTokenDto) (*models.Token, error) <span class="cov0" title="0">{
        token := &amp;models.Token{
                Token:     in.Token,
                UserID:    in.UserID,
                ExpiresAt: in.ExpiresAt,
        }

        result := r.db.GetDb().Create(&amp;token)

        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}

func (r *tokenPgRepository) FindByToken(t string) (*models.Token, error) <span class="cov0" title="0">{
        var token models.Token

        result := r.db.GetDb().Where(models.Token{
                Token: t,
        }).First(&amp;token)

        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return &amp;token, nil</span>
}

func (r *tokenPgRepository) Delete(t string) error <span class="cov0" title="0">{
        var token models.Token

        result := r.db.GetDb().Where(models.Token{
                Token: t,
        }).Delete(&amp;token)

        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package user_repository

import (
        "errors"

        "github.com/ddan1l/tega-backend/database"
        user_dto "github.com/ddan1l/tega-backend/dto/user"
        "github.com/ddan1l/tega-backend/models"
        "gorm.io/gorm"
)

type userPgRepository struct {
        db database.Database
}

func NewUserPgRepository(db database.Database) UserRepository <span class="cov8" title="1">{
        return &amp;userPgRepository{db: db}
}</span>

func (r *userPgRepository) Create(in *user_dto.CreateUserDto) (*models.User, error) <span class="cov8" title="1">{
        user := &amp;models.User{
                FullName:     in.FullName,
                Email:        in.Email,
                PasswordHash: in.PasswordHash,
        }

        result := r.db.GetDb().Create(&amp;user)

        if result.Error != nil </span><span class="cov8" title="1">{
                return nil, result.Error
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func (r *userPgRepository) FindById(in *user_dto.FindByIdDto) (*models.User, error) <span class="cov8" title="1">{
        var user models.User

        result := r.db.GetDb().Where(models.User{
                ID: in.ID,
        }).First(&amp;user)

        if result.Error != nil </span><span class="cov8" title="1">{
                return nil, result.Error
        }</span>

        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *userPgRepository) FindByEmail(in *user_dto.FindByEmailDto) (*models.User, error) <span class="cov8" title="1">{
        var user models.User

        result := r.db.GetDb().Where(models.User{
                Email: in.Email,
        }).First(&amp;user)

        if result.Error != nil </span><span class="cov8" title="1">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>

                <span class="cov8" title="1">return nil, result.Error</span>
        }

        <span class="cov8" title="1">return &amp;user, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package server

import (
        "fmt"
        "log"
        "os"

        "github.com/ddan1l/tega-backend/config"
        "github.com/ddan1l/tega-backend/database"
        "github.com/ddan1l/tega-backend/factory"
        auth_handler "github.com/ddan1l/tega-backend/handlers/auth"
        auth_middleware "github.com/ddan1l/tega-backend/middleware/auth"
        "github.com/gin-gonic/gin"
)

type ginServer struct {
        app     *gin.Engine
        db      database.Database
        conf    *config.Config
        factory *factory.DefaultFactory
}

func NewGinServer(conf *config.Config, db database.Database) Server <span class="cov0" title="0">{
        app := gin.Default()
        factory := factory.NewDefaultFactory(db)

        log.SetOutput(os.Stdout)
        log.SetFlags(log.LstdFlags | log.Lshortfile)

        return &amp;ginServer{
                app:     app,
                db:      db,
                conf:    conf,
                factory: factory,
        }
}</span>

func (s *ginServer) Start() <span class="cov0" title="0">{
        s.initializeAuthHandler()

        authMiddleware := auth_middleware.NewAuthMiddleware(
                s.factory.CreateAuthUseCase(),
        )

        s.app.Use(authMiddleware.Middleware())

        s.app.GET("/protected", func(c *gin.Context) </span><span class="cov0" title="0">{
                u, _ := c.Get("user")
                c.JSON(200, gin.H{
                        "message": u,
                })
        }</span>)

        <span class="cov0" title="0">serverUrl := fmt.Sprintf(":%d", s.conf.Server.Port)
        s.app.Run(serverUrl)</span>
}

func (s *ginServer) initializeAuthHandler() <span class="cov0" title="0">{
        authHandler := auth_handler.NewAuthHandler(
                s.factory.CreateAuthUseCase(),
        )

        g := s.app.Group("/auth")

        g.POST("/register", authHandler.Register)
        g.POST("/login", authHandler.Login)
        g.POST("/logout", authHandler.Logout)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package auth_usecase

import (
        "errors"
        "time"

        auth_dto "github.com/ddan1l/tega-backend/dto/auth"
        user_dto "github.com/ddan1l/tega-backend/dto/user"
        errs "github.com/ddan1l/tega-backend/errors"
        token_repository "github.com/ddan1l/tega-backend/repositories/token"
        user_repository "github.com/ddan1l/tega-backend/repositories/user"
        "github.com/ddan1l/tega-backend/utils"
        "github.com/golang-jwt/jwt/v5"
)

var accessSecret = []byte("access_secret_key2")
var refreshSecret = []byte("refresh_secret_key")

type JwtClaims struct {
        UserID int `json:"user_id"`
        jwt.RegisteredClaims
}

type authUsecaseImpl struct {
        userRepository  user_repository.UserRepository
        tokenRepository token_repository.TokenRepository
}

func NewAuthUsecaseImpl(
        userRepository user_repository.UserRepository,
        tokenRepository token_repository.TokenRepository,
) AuthUsecase <span class="cov0" title="0">{
        return &amp;authUsecaseImpl{
                userRepository:  userRepository,
                tokenRepository: tokenRepository,
        }
}</span>

// RegisterUser creates a new user account and returns JWT tokens.
// Performs email availability check and password hashing.
func (u *authUsecaseImpl) RegisterUser(in *auth_dto.RegisterUserDto) (*auth_dto.TokensPairDto, *errs.AppError) <span class="cov0" title="0">{

        if err := u.CheckUserExists(in.Email); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if hash, err := utils.HashPassword(in.Password); err != nil </span><span class="cov0" title="0">{
                return nil, errs.Auth.WithError(err)
        }</span> else<span class="cov0" title="0"> {
                user, err := u.userRepository.Create(&amp;user_dto.CreateUserDto{
                        Email:        in.Email,
                        FullName:     in.FullName,
                        PasswordHash: hash,
                })

                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs.Auth.WithError(err)
                }</span>

                <span class="cov0" title="0">if pair, err := u.issuePair(user.ID); err != nil </span><span class="cov0" title="0">{
                        return nil, errs.Auth.WithError(err)
                }</span> else<span class="cov0" title="0"> {
                        _, err := u.tokenRepository.Create(&amp;auth_dto.CreateTokenDto{
                                UserID:    user.ID,
                                Token:     pair.RefreshToken,
                                ExpiresAt: time.Now().Add(RefreshTokenMaxAge),
                        })

                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs.Auth.WithError(err)
                        }</span>

                        <span class="cov0" title="0">return pair, nil</span>
                }
        }
}

// LoginUser authenticates a user by email/password and returns new JWT tokens.
func (u *authUsecaseImpl) LoginUser(in *auth_dto.LoginUserDto) (*auth_dto.TokensPairDto, *errs.AppError) <span class="cov0" title="0">{
        user, err := u.userRepository.FindByEmail(&amp;user_dto.FindByEmailDto{
                Email: in.Email,
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Auth.WithError(err)
        }</span>

        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, errs.UserNotFound
        }</span>

        <span class="cov0" title="0">if ok := utils.CheckPasswordHash(in.Password, user.PasswordHash); !ok </span><span class="cov0" title="0">{
                return nil, errs.IncorrectPassword
        }</span> else<span class="cov0" title="0"> {
                if pair, err := u.issuePair(user.ID); err != nil </span><span class="cov0" title="0">{
                        return nil, errs.Auth.WithError(err)
                }</span> else<span class="cov0" title="0"> {
                        _, err := u.tokenRepository.Create(&amp;auth_dto.CreateTokenDto{
                                UserID:    user.ID,
                                Token:     pair.RefreshToken,
                                ExpiresAt: time.Now().Add(RefreshTokenMaxAge),
                        })

                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs.Auth.WithError(err)
                        }</span>

                        <span class="cov0" title="0">return pair, nil</span>
                }
        }

}

// CheckUserExists verifies if a user with the given email already exists.
// Returns:
//   - nil if email is available
//   - AlreadyExists if user found
//   - Auth-wrapped error for repository failures
func (u *authUsecaseImpl) CheckUserExists(e string) *errs.AppError <span class="cov0" title="0">{
        user, err := u.userRepository.FindByEmail(&amp;user_dto.FindByEmailDto{
                Email: e,
        })

        if err != nil </span><span class="cov0" title="0">{
                return errs.Auth.WithError(err)
        }</span>

        <span class="cov0" title="0">if user != nil </span><span class="cov0" title="0">{
                return errs.AlreadyExists
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// issuePair generates a new pair of JWT tokens (access and refresh) for the given user ID.
// Returns:
//   - TokensPairDto containing both tokens on success
//   - Auth-wrapped error if either token generation fails
func (u *authUsecaseImpl) issuePair(id int) (*auth_dto.TokensPairDto, *errs.AppError) <span class="cov0" title="0">{

        accessToken, err := u.issueToken(&amp;auth_dto.IssueTokenDto{
                UserID:    id,
                ExpiresAt: time.Now().Add(AccessTokenMaxAge),
                Secret:    accessSecret,
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Auth.WithError(err)
        }</span>

        <span class="cov0" title="0">refreshToken, err := u.issueToken(&amp;auth_dto.IssueTokenDto{
                UserID:    id,
                ExpiresAt: time.Now().Add(RefreshTokenMaxAge),
                Secret:    refreshSecret,
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Auth.WithError(err)
        }</span>

        <span class="cov0" title="0">return &amp;auth_dto.TokensPairDto{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
        }, nil</span>
}

// issueToken generates a JWT token for the specified user ID with given secret key.
// The token contains:
//   - user_id claim (provided userID)
//   - exp claim (15 minutes from issuance)
//
// Returns:
//   - Signed token string on success
//   - Auth-wrapped error if signing fails
func (u *authUsecaseImpl) issueToken(in *auth_dto.IssueTokenDto) (string, *errs.AppError) <span class="cov0" title="0">{

        claims := JwtClaims{
                UserID: in.UserID,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(in.ExpiresAt),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        tokenString, err := token.SignedString(in.Secret)

        if err != nil </span><span class="cov0" title="0">{
                return "", errs.Auth.WithError(err)
        }</span> else<span class="cov0" title="0"> {
                return tokenString, nil
        }</span>
}

// parseToken validates and parses a JWT token using the provided secret.
// Returns:
//   - JwtClaims if token is valid
//   - AppError with:
//   - TokenExpired if token expired
//   - Forbidden for any other validation errors (invalid signature, malformed token, etc.)
func (u *authUsecaseImpl) parseToken(in *auth_dto.ParseTokenDto) (*JwtClaims, *errs.AppError) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(in.Token, &amp;JwtClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return in.Secret, nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, jwt.ErrTokenExpired) </span><span class="cov0" title="0">{
                        return nil, errs.TokenExpired
                }</span>
                <span class="cov0" title="0">return nil, errs.Forbidden.WithError(err)</span>
        }

        <span class="cov0" title="0">if claims, ok := token.Claims.(*JwtClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, errs.Forbidden.WithError(err)</span>
}

// Authenticate handles user authentication using either access or refresh token
// Returns authenticated user data with new access token if refresh was used
func (u *authUsecaseImpl) Authenticate(in *auth_dto.TokensPairDto) (*auth_dto.AuthenticatedDto, *errs.AppError) <span class="cov0" title="0">{
        // Initialize validation flags and output variables
        var (
                isEmptyAccess  = in.AccessToken == ""  // Flag for empty access token
                isEmptyRefresh = in.RefreshToken == "" // Flag for empty refresh token
                isEmptyPair    = isEmptyAccess &amp;&amp; isEmptyRefresh
                newAccessToken = "" // Will contain new access token if generated
                userID         = 0  // Will store authenticated user ID
        )

        // Reject requests with no valid tokens
        if isEmptyPair || isEmptyRefresh </span><span class="cov0" title="0">{
                return nil, errs.Forbidden
        }</span>

        // Case 1: Only refresh token provided (access token expired/missing)
        <span class="cov0" title="0">if isEmptyAccess </span><span class="cov0" title="0">{
                // Validate refresh token structure and signature
                _, errRefreshToken := u.parseToken(&amp;auth_dto.ParseTokenDto{
                        Token:  in.RefreshToken,
                        Secret: refreshSecret,
                })

                if errRefreshToken != nil </span><span class="cov0" title="0">{
                        return nil, errRefreshToken
                }</span>

                // Check if refresh token exists in database (not revoked)
                <span class="cov0" title="0">refreshToken, errFindToken := u.tokenRepository.FindByToken(in.RefreshToken)
                if errFindToken != nil </span><span class="cov0" title="0">{
                        return nil, errs.Forbidden.WithError(errFindToken)
                }</span>

                // Prepare data for new access token generation
                <span class="cov0" title="0">newAccessTokenDto := &amp;auth_dto.IssueTokenDto{
                        UserID:    refreshToken.UserID, // Use ID from refresh token
                        ExpiresAt: time.Now().Add(AccessTokenMaxAge),
                        Secret:    accessSecret,
                }

                // Generate new access token
                if accessToken, err := u.issueToken(newAccessTokenDto); err != nil </span><span class="cov0" title="0">{
                        return nil, errs.Forbidden.WithError(err)
                }</span> else<span class="cov0" title="0"> {
                        newAccessToken = accessToken
                        userID = refreshToken.UserID
                }</span>

        } else<span class="cov0" title="0"> {
                // Case 2: Valid access token provided
                claims, errAccessToken := u.parseToken(&amp;auth_dto.ParseTokenDto{
                        Token:  in.AccessToken,
                        Secret: accessSecret,
                })

                if errAccessToken != nil </span><span class="cov0" title="0">{
                        return nil, errAccessToken
                }</span>

                <span class="cov0" title="0">userID = claims.UserID</span> // Extract user ID from access token claims
        }

        // Fetch full user data by ID obtained from tokens
        <span class="cov0" title="0">user, errFindUser := u.userRepository.FindById(&amp;user_dto.FindByIdDto{
                ID: userID,
        })

        if errFindUser != nil </span><span class="cov0" title="0">{
                return nil, errs.Forbidden.WithError(errFindUser)
        }</span>

        // Prepare successful response
        <span class="cov0" title="0">result := auth_dto.AuthenticatedDto{
                User:        user,           // User profile data
                AccessToken: newAccessToken, // New access token (empty if original was valid)
        }

        return &amp;result, nil</span>
}

// Delete token from database
func (u *authUsecaseImpl) DeleteToken(t string) *errs.AppError <span class="cov0" title="0">{
        err := u.tokenRepository.Delete(t)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Auth.WithError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package utils

import "github.com/gin-gonic/gin"

func SafeGetCookie(c *gin.Context, name string) string <span class="cov0" title="0">{
        for _, cookie := range c.Request.Cookies() </span><span class="cov0" title="0">{
                if cookie.Name == name </span><span class="cov0" title="0">{
                        return cookie.Value
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package utils

import (
        "golang.org/x/crypto/bcrypt"
)

func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(bytes), err
}</span>

func CheckPasswordHash(password, hash string) bool <span class="cov0" title="0">{
        return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) == nil
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package req

import (
        "errors"
        "fmt"
        "net/http"

        errs "github.com/ddan1l/tega-backend/errors"
        res "github.com/ddan1l/tega-backend/web/responses"
        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
)

var validate *validator.Validate

func BindAndValidate(c *gin.Context, obj interface{}) bool <span class="cov0" title="0">{
        validate = validator.New(validator.WithRequiredStructEnabled())

        c.ShouldBindJSON(&amp;obj)

        err := validate.Struct(obj)

        if err != nil </span><span class="cov0" title="0">{

                // this check is only needed when your code could produce
                // an invalid value for validation such as interface with nil
                // value most including myself do not usually have code like this.
                var invalidValidationError *validator.InvalidValidationError

                if errors.As(err, &amp;invalidValidationError) </span><span class="cov0" title="0">{
                        return errorWith(c, http.StatusBadRequest, "BAD_REQUEST", err.Error(), nil)
                }</span>

                <span class="cov0" title="0">var validateErrs validator.ValidationErrors

                var details = make(map[string]string)

                if errors.As(err, &amp;validateErrs) </span><span class="cov0" title="0">{
                        for _, e := range validateErrs </span><span class="cov0" title="0">{
                                // e.Namespace()
                                // e.Field()
                                // e.StructNamespace()
                                // e.StructField()
                                // e.Tag()
                                // e.ActualTag()
                                // e.Kind()
                                // e.Type()
                                // e.Value()
                                // e.Param()

                                if len(e.Param()) &gt; 0 </span><span class="cov0" title="0">{
                                        details[e.Field()] = fmt.Sprintf("Must be %s %s", e.Tag(), e.Param())
                                }</span> else<span class="cov0" title="0"> {
                                        details[e.Field()] = fmt.Sprintf("Must be %s", e.Tag())
                                }</span>

                        }
                }

                <span class="cov0" title="0">return errorWith(c, http.StatusUnprocessableEntity, "VALIDATION_ERROR", "Invalid input", details)</span>
        }

        <span class="cov0" title="0">return true</span>
}

func errorWith(c *gin.Context, status int, code, message string, details interface{}) bool <span class="cov0" title="0">{
        res.ErrorResponse(c, &amp;errs.AppError{
                Status:  status,
                Code:    code,
                Message: message,
                Details: details,
        })
        return false
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package res

import (
        errs "github.com/ddan1l/tega-backend/errors"
        "github.com/gin-gonic/gin"
)

func ErrorResponse(c *gin.Context, err *errs.AppError) <span class="cov0" title="0">{
        c.JSON(err.Status, gin.H{"error": &amp;err, "success": false})
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package res

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

func SuccessResponse(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{"success": true})
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
